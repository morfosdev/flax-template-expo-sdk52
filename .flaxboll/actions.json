{"1742405598613":{"actionType":"saveAll","createdAt":"1742405598613","actionID":"1742405598613","userID":"#TEMP","path":"system.capsules.4a541072-7bf3-4396-87fd-11e9879a9e04.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Packs\nimport React from 'react';\nimport JSON5 from 'json5';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { getVarValue, getStlValues, pathSel } from '../project';\nimport { useData } from '../../..';\n\ntype Tprops = {\n  pass: {\n    propsArray: any;\n    stylesArray: any;\n    funcsArray: any;\n    path: string[];\n    args: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  // ------- set IptTxt Inputs\n  const { propsArray, stylesArray, funcsArray, path, args } = props.pass;\n\n  // --------------------------\n  // ----------- set COND VALUE\n  // --------------------------\n  const joinedPath = path.join('.'); // Corrigido para usar ponto como delimitador\n  const splitedPathArr = joinedPath.split('.');\n  const idxToAdd = splitedPathArr.length - 2;\n\n  // Cria c처pias separadas para evitar conflitos com splice\n  const splitedPathArrEdit = [...splitedPathArr];\n  splitedPathArrEdit.splice(idxToAdd, 0, 'editData');\n  const editPath = splitedPathArrEdit.join('.');\n\n  const splitedPathArrNew = [...splitedPathArr];\n  splitedPathArrNew.splice(idxToAdd, 0, 'iptsChanges');\n  const newPath = splitedPathArrNew.join('.');\n\n  // ------- set Data to Watch\n  const [sttText, setText] = React.useState('');\n\n  // Observar os dados nas paths separadas\n  const editData = useData(ct => pathSel(ct, splitedPathArrEdit));\n  const newData = useData(ct => pathSel(ct, splitedPathArrNew));\n\n  // Efeito colateral ao alterar editData\n  React.useEffect(() => {\n    if (!editData) {\n      // Se editData n찾o existe, poderia processar algo com newPath\n      // Exemplo: console.log('editData vazio, usar newPath:', newPath);\n    }\n  }, [editData]);\n\n  // ---------- Functions\n  const getTxt = async (val: string) => {\n    for (const currFunc of funcsArray) {\n      await currFunc(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ------- set User Element Properties (If Exists)\n  const userElProps: any = {};\n  for (let strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n\n    const parsedObject = JSON5.parse(strObj);\n\n    for (const keyProp in parsedObject) {\n      const valueProp = parsedObject[keyProp];\n      const [hasVar, varValue] = getVarValue(valueProp);\n      userElProps[keyProp] = hasVar ? varValue : valueProp;\n    }\n  }\n\n  // Combina todas as props do TextInput\n  const allProps = {\n    style: stlsUser,\n    onChangeText: getTxt,\n    value: sttText,\n    placeholderTextColor: '#ccc',\n    placeholder: 'Escreva...',\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};","newValue":"// ---------- import Packs\nimport React from 'react';\nimport JSON5 from 'json5';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { getVarValue, getStlValues, pathSel } from '../project';\nimport { useData } from '../../..';\n\ntype Tprops = {\n  pass: {\n    propsArray: any;\n    stylesArray: any;\n    funcsArray: any;\n    path: string[];\n    args: any;\n  };\n};\n\nexport const IptTxtEdit = (props: Tprops) => {\n  // ------- set IptTxt Inputs\n  const { propsArray, stylesArray, funcsArray, path, args } = props.pass;\n\n  // --------------------------\n  // ----------- set COND VALUE\n  // --------------------------\n  // const joinedPath = path.join('.'); // Corrigido para usar ponto como delimitador\n  // const splitedPathArr = joinedPath.split('.');\n  const idxToAdd = path.length - 2;\n\n  // Cria c처pias separadas para evitar conflitos com splice\n  const splitedPathArrEdit = [...path];\n  splitedPathArrEdit.splice(idxToAdd, 0, 'editData');\n  const editPath = splitedPathArrEdit.join('.');\n\n  const splitedPathArrNew = [...path];\n  splitedPathArrNew.splice(idxToAdd, 0, 'iptsChanges');\n  const newPath = splitedPathArrNew.join('.');\n\n  // ------- set Data to Watch\n  const [sttText, setText] = React.useState('');\n\n  // Observar os dados nas paths separadas\n  const editData = useData(ct => pathSel(ct, splitedPathArrEdit));\n  const newData = useData(ct => pathSel(ct, splitedPathArrNew));\n\n  // Efeito colateral ao alterar editData\n  React.useEffect(() => {\n    if (!editData) {\n      // Se editData n찾o existe, poderia processar algo com newPath\n      // Exemplo: console.log('editData vazio, usar newPath:', newPath);\n    }\n  }, [editData]);\n\n  // ---------- Functions\n  const getTxt = async (val: string) => {\n    for (const currFunc of funcsArray) {\n      await currFunc(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ------- set User Element Properties (If Exists)\n  const userElProps: any = {};\n  for (let strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n\n    const parsedObject = JSON5.parse(strObj);\n\n    for (const keyProp in parsedObject) {\n      const valueProp = parsedObject[keyProp];\n      const [hasVar, varValue] = getVarValue(valueProp);\n      userElProps[keyProp] = hasVar ? varValue : valueProp;\n    }\n  }\n\n  // Combina todas as props do TextInput\n  const allProps = {\n    style: stlsUser,\n    onChangeText: getTxt,\n    value: sttText,\n    placeholderTextColor: '#ccc',\n    placeholder: 'Escreva...',\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};"}}